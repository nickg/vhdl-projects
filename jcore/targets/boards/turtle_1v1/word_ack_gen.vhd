-- ******************************************************************
-- ******************************************************************
-- ******************************************************************
-- This file is generated by soc_gen and will be overwritten next time
-- the tool is run. See soc_top/README for information on running soc_gen.
-- ******************************************************************
-- ******************************************************************
-- ******************************************************************
library ieee;
use ieee.std_logic_1164.all;

entity word_ack_gen is
  port (
    adr : in std_logic_vector( 31 downto 0);
    word_bus_en : in std_logic ;
    ack_thru_in_aic0     : in std_logic ;
    ack_thru_in_aic1     : in std_logic ;
    ack_thru_in_emac     : in std_logic ;
    ack_thru_in_uart0    : in std_logic ;
    ack_thru_in_gpsif    : in std_logic ;
    word_ack : out std_logic
  );
end entity;

architecture impl of word_ack_gen is
    type device_t is (NONE, DEV_AIC0, DEV_AIC1, DEV_CACHE_CTRL, DEV_EMAC, DEV_FLASH, DEV_GPIO, DEV_GPSIF, DEV_UART0);
    function decode_address_wag (addr : 
      std_logic_vector(31 downto 0)) return device_t is
    begin
        -- Assumes addr(31 downto 28) = x"a".
        -- Address decoding closer to CPU checks those bits.
        if addr(27 downto 18) = "1011110011" then
            if addr(17) = '0' then
                if addr(16) = '0' then
                    -- ABCC0000-ABCC03FF
                    return DEV_GPSIF;
                elsif addr(16 downto 11) = "100000" then
                    if addr(10) = '0' then
                        if addr(9) = '0' then
                            if addr(8) = '0' then
                                if addr(7) = '0' then
                                    if addr(6) = '0' then
                                        -- ABCD0000-ABCD000F
                                        return DEV_GPIO;
                                    else
                                        -- ABCD0040-ABCD0047
                                        return DEV_FLASH;
                                    end if;
                                else
                                    -- ABCD00C0-ABCD00FF
                                    return DEV_CACHE_CTRL;
                                end if;
                            else
                                -- ABCD0100-ABCD010F
                                return DEV_UART0;
                            end if;
                        else
                            -- ABCD0200-ABCD023F
                            return DEV_AIC0;
                        end if;
                    else
                        -- ABCD0500-ABCD053F
                        return DEV_AIC1;
                    end if;
                end if;
            else
                -- ABCE0000-ABCE1FFF
                return DEV_EMAC;
            end if;
        end if;
        return NONE;
    end;
begin
    ack_gen : process (
      ack_thru_in_aic0, ack_thru_in_aic1, ack_thru_in_emac,
      ack_thru_in_uart0,
      word_bus_en, adr
      )
      variable active_dev : device_t;
    begin
      active_dev := decode_address_wag ( adr );
      case active_dev is
        when DEV_AIC0     => word_ack <= ack_thru_in_aic0;
        when DEV_AIC1     => word_ack <= ack_thru_in_aic1;
        when DEV_EMAC     => word_ack <= ack_thru_in_emac;
        when DEV_UART0    => word_ack <= ack_thru_in_uart0;
        when DEV_GPSIF    => word_ack <= ack_thru_in_gpsif;
        when others       => word_ack <= word_bus_en;
      end case;
    end process;
end impl;
